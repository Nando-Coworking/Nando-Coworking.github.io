-- =====================================================
-- 0. Preliminary: Drop triggers, functions, policies, and tables if they exist
--    (in correct dependency order).
-- =====================================================

DO $$
BEGIN
    -- Drop triggers (must drop before dropping functions)
    IF EXISTS (
        SELECT 1 
        FROM pg_trigger 
        WHERE tgname = 'update_group_updated_at'
    ) THEN
        DROP TRIGGER update_group_updated_at ON public.groups;
    END IF;
    IF EXISTS (
        SELECT 1 
        FROM pg_trigger 
        WHERE tgname = 'update_group_users_updated_at'
    ) THEN
        DROP TRIGGER update_group_users_updated_at ON public.group_users;
    END IF;
    IF EXISTS (
        SELECT 1 
        FROM pg_trigger 
        WHERE tgname = 'update_sites_updated_at'
    ) THEN
        DROP TRIGGER update_sites_updated_at ON public.sites;
    END IF;
    IF EXISTS (
        SELECT 1 
        FROM pg_trigger 
        WHERE tgname = 'update_resources_updated_at'
    ) THEN
        DROP TRIGGER update_resources_updated_at ON public.resources;
    END IF;
    IF EXISTS (
        SELECT 1
        FROM pg_trigger
        WHERE tgname = 'update_amenities_updated_at'
    ) THEN
        DROP TRIGGER update_amenities_updated_at ON public.amenities;
    END IF;
    IF EXISTS (
        SELECT 1
        FROM pg_trigger
        WHERE tgname = 'update_resource_amenities_updated_at'
    ) THEN
        DROP TRIGGER update_resource_amenities_updated_at ON public.resource_amenities;
    END IF;
    IF EXISTS (
        SELECT 1
        FROM pg_trigger
        WHERE tgname = 'update_reservations_updated_at'
    ) THEN
        DROP TRIGGER update_reservations_updated_at ON public.reservations;
    END IF;
EXCEPTION WHEN OTHERS THEN
    RAISE NOTICE 'Error dropping triggers: %', SQLERRM;
END $$;

-- Drop functions if they exist
DROP FUNCTION IF EXISTS update_updated_at CASCADE;
DROP FUNCTION IF EXISTS validate_reservation_visibility CASCADE;

-- Drop policies if they exist
DO $$
DECLARE
    policy_rec RECORD;
BEGIN
    FOR policy_rec IN 
        SELECT policyname, tablename
        FROM pg_policies
        WHERE schemaname = 'public'
    LOOP
        EXECUTE format(
            'DROP POLICY IF EXISTS "%I" ON public.%I;',
            policy_rec.policyname,
            policy_rec.tablename
        );
    END LOOP;
END $$;

-- Drop tables if they exist (correct dependency order)
DROP TABLE IF EXISTS public.resource_amenities CASCADE;
DROP TABLE IF EXISTS public.reservations CASCADE;
DROP TABLE IF EXISTS public.amenities CASCADE;
DROP TABLE IF EXISTS public.resources CASCADE;
DROP TABLE IF EXISTS public.sites CASCADE;
DROP TABLE IF EXISTS public.group_users CASCADE;
DROP TABLE IF EXISTS public.groups CASCADE;

-- =====================================================
-- 1. Create the "groups" and "group_users" tables
--    (For organizational ownership).
-- =====================================================

CREATE TABLE public.groups (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    name varchar(255) NOT NULL,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

-- A table mapping which users (from auth.users) belong to which group,
-- with a role (e.g. 'owner', 'admin', 'member', etc.).
CREATE TABLE public.group_users (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    group_id uuid REFERENCES public.groups(id) ON DELETE CASCADE,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    role varchar(50) NOT NULL DEFAULT 'member',
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    UNIQUE (group_id, user_id)
);

-- =====================================================
-- Create the is_group_admin function
-- =====================================================

CREATE OR REPLACE FUNCTION is_group_admin(_group_id uuid, _uid uuid)
  RETURNS boolean
  LANGUAGE sql
  SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.group_users
    WHERE group_id = _group_id
      AND user_id = _uid
      AND role IN ('owner','admin')
  );
$$;

-- Add this after the is_group_admin function and before the policies

-- Function to create a group and make creator the owner
CREATE OR REPLACE FUNCTION create_group_with_owner(
  _name varchar,
  _description text,
  _user_id uuid
) RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  _group_id uuid;
BEGIN
  -- Insert the group
  INSERT INTO groups (name, description)
  VALUES (_name, _description)
  RETURNING id INTO _group_id;

  -- Make the creator an owner
  INSERT INTO group_users (group_id, user_id, role)
  VALUES (_group_id, _user_id, 'owner');

  RETURN _group_id;
END;
$$;

-- =====================================================
-- 2. Create the "sites" table
--    (Physical coworking locations, owned by a group).
-- =====================================================

CREATE TABLE public.sites (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    group_id uuid REFERENCES public.groups(id) ON DELETE CASCADE,
    name varchar(255) NOT NULL,
    description text,
    address1 varchar(255),
    address2 varchar(255),
    city varchar(100),
    state varchar(100),
    postal_code varchar(20),
    phone varchar(50),
    slug_name varchar(255),
    -- Optional: base64 representation of an image.
    base64_image text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

-- =====================================================
-- 3. Create the "resources" table
--    (Individual bookable spaces within a site).
-- =====================================================

CREATE TABLE public.resources (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    site_id uuid REFERENCES public.sites(id) ON DELETE CASCADE,
    name varchar(255) NOT NULL,
    description text,
    location_description text,
    max_occupants integer,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now()
);

-- =====================================================
-- 4. Create the "amenities" table + "resource_amenities" junction
--    (For many-to-many relationships between resources & amenities).
-- =====================================================

CREATE TABLE public.amenities (
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    name text,
    description text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    UNIQUE (name)
);

CREATE TABLE public.resource_amenities (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    resource_id uuid REFERENCES public.resources(id) ON DELETE CASCADE,
    amenity_id uuid REFERENCES public.amenities(id) ON DELETE CASCADE,
    name_override text,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    UNIQUE (resource_id, amenity_id)
);

-- =====================================================
-- 5. Create the "reservations" table
--    (Where we store ICS-like booking data).
-- =====================================================
-- We store typical ICS fields:
--  - title, description, start_time, end_time, rrule
--  - 'participants' text[] or a separate table.
--
-- By default:
--  - user_id is the user who booked it.
--  - resource_id is the space being booked.

CREATE TABLE public.reservations (
    id uuid DEFAULT gen_random_uuid() PRIMARY KEY,
    resource_id uuid REFERENCES public.resources(id) ON DELETE CASCADE,
    user_id uuid REFERENCES auth.users(id) ON DELETE CASCADE,
    title varchar(255) NOT NULL,
    description text,
    start_time timestamp with time zone NOT NULL,
    end_time timestamp with time zone NOT NULL,
    rrule text,   -- RFC 5545 recurrence rule string
    participants text[],  -- list of email addresses or user IDs
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    -- Just a sanity check that end_time is after start_time
    CONSTRAINT check_event_times CHECK (end_time > start_time)
);

-- =====================================================
-- 6. Enable Row Level Security (RLS) on all tables.
-- =====================================================

ALTER TABLE public.groups ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.group_users ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.sites ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.resources ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.amenities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.resource_amenities ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.reservations ENABLE ROW LEVEL SECURITY;

-- =====================================================
-- 7. Create a function & trigger to auto-update "updated_at".
-- =====================================================

CREATE OR REPLACE FUNCTION update_updated_at()
RETURNS TRIGGER AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Attach the trigger to each table that needs timestamp tracking

CREATE TRIGGER update_group_updated_at
BEFORE UPDATE ON public.groups
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_group_users_updated_at
BEFORE UPDATE ON public.group_users
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_sites_updated_at
BEFORE UPDATE ON public.sites
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_resources_updated_at
BEFORE UPDATE ON public.resources
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_amenities_updated_at
BEFORE UPDATE ON public.amenities
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_resource_amenities_updated_at
BEFORE UPDATE ON public.resource_amenities
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

CREATE TRIGGER update_reservations_updated_at
BEFORE UPDATE ON public.reservations
FOR EACH ROW
EXECUTE FUNCTION update_updated_at();

-- =====================================================
-- 8. Define Row-Level Security Policies
--    Below are some example policies; tailor as needed.
-- =====================================================

-- -----------------------------------------------------
-- groups
-- -----------------------------------------------------
-- Only group owners/members can SELECT or modify the group row

CREATE POLICY "group_select_policy"
ON public.groups
FOR SELECT
TO authenticated
USING (
   -- user is in 'group_users' for this group
   EXISTS (
     SELECT 1 
     FROM public.group_users 
     WHERE group_users.group_id = groups.id
       AND group_users.user_id = auth.uid()
   )
);

-- First, drop existing policies
DROP POLICY IF EXISTS "group_insert_policy" ON public.groups;
DROP POLICY IF EXISTS "group_users_insert_policy" ON public.group_users;

-- Modified groups insert policy - simpler and more permissive for creation
CREATE POLICY "group_insert_policy"
ON public.groups
FOR INSERT
TO authenticated
WITH CHECK (false);  -- Force group creation through the function

-- Modified group_users insert policy - allow self-insertion as owner
CREATE POLICY "group_users_insert_policy"
ON public.group_users
FOR INSERT
TO authenticated
WITH CHECK (
   -- Allow user to insert themselves as owner when creating group
   (user_id = auth.uid() AND role = 'owner')
   OR
   -- OR allow existing group admins to add other users
   EXISTS (
     SELECT 1 
     FROM public.group_users AS me
     WHERE me.group_id = group_users.group_id
       AND me.user_id = auth.uid()
       AND me.role IN ('owner', 'admin')
   )
);

CREATE POLICY "group_update_policy"
ON public.groups
FOR UPDATE
TO authenticated
USING (
   EXISTS (
     SELECT 1 
     FROM public.group_users 
     WHERE group_users.group_id = groups.id
       AND group_users.user_id = auth.uid()
       -- Possibly enforce role = 'owner' or 'admin'
   )
)
WITH CHECK (
   EXISTS (
     SELECT 1 
     FROM public.group_users 
     WHERE group_users.group_id = groups.id
       AND group_users.user_id = auth.uid()
   )
);

CREATE POLICY "group_delete_policy"
ON public.groups
FOR DELETE
TO authenticated
USING (
   EXISTS (
     SELECT 1 
     FROM public.group_users 
     WHERE group_users.group_id = groups.id
       AND group_users.user_id = auth.uid()
       -- Possibly enforce role = 'owner'
   )
);

-- -----------------------------------------------------
-- group_users
-- -----------------------------------------------------
-- Only group members with certain roles can see or modify membership

CREATE POLICY "group_users_select_policy"
ON public.group_users
FOR SELECT
TO authenticated
USING (
  user_id = auth.uid()
  OR is_group_admin(group_users.group_id, auth.uid())
);

CREATE POLICY "group_users_update_policy"
ON public.group_users
FOR UPDATE
TO authenticated
USING (
   EXISTS (
     SELECT 1 
     FROM public.group_users AS me
     WHERE me.group_id = group_users.group_id
       AND me.user_id = auth.uid()
       AND me.role IN ('owner', 'admin')
   )
)
WITH CHECK (
   EXISTS (
     SELECT 1 
     FROM public.group_users AS me
     WHERE me.group_id = group_users.group_id
       AND me.user_id = auth.uid()
       AND me.role IN ('owner', 'admin')
   )
);

CREATE POLICY "group_users_delete_policy"
ON public.group_users
FOR DELETE
TO authenticated
USING (
   -- Allow users to remove themselves (except owners)
   (user_id = auth.uid() AND role != 'owner')
   OR
   -- OR allow group admins to remove others  
   EXISTS (
     SELECT 1 
     FROM public.group_users AS me
     WHERE me.group_id = group_users.group_id
       AND me.user_id = auth.uid()
       AND me.role IN ('owner', 'admin')
   )
);

-- -----------------------------------------------------
-- sites
-- -----------------------------------------------------
-- Only group members can see the site. Only admins can modify.

CREATE POLICY "sites_select_policy"
ON public.sites
FOR SELECT
TO authenticated
USING (
   EXISTS (
     SELECT 1
     FROM public.group_users
     WHERE group_users.group_id = sites.group_id
       AND group_users.user_id = auth.uid()
   )
);

CREATE POLICY "sites_insert_policy"
ON public.sites
FOR INSERT
TO authenticated
WITH CHECK (
   -- user can create a site only if they're an admin in the group
   EXISTS (
     SELECT 1
     FROM public.group_users
     WHERE group_users.group_id = sites.group_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner', 'admin')
   )
);

CREATE POLICY "sites_update_policy"
ON public.sites
FOR UPDATE
TO authenticated
USING (
   EXISTS (
     SELECT 1
     FROM public.group_users
     WHERE group_users.group_id = sites.group_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner', 'admin')
   )
)
WITH CHECK (
   EXISTS (
     SELECT 1
     FROM public.group_users
     WHERE group_users.group_id = sites.group_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner', 'admin')
   )
);

CREATE POLICY "sites_delete_policy"
ON public.sites
FOR DELETE
TO authenticated
USING (
   EXISTS (
     SELECT 1
     FROM public.group_users
     WHERE group_users.group_id = sites.group_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner')
   )
);

-- -----------------------------------------------------
-- resources
-- -----------------------------------------------------
-- Similar pattern: only group members can see a resource, only admins can modify.

CREATE POLICY "resources_select_policy"
ON public.resources
FOR SELECT
TO authenticated
USING (
   EXISTS (
     SELECT 1
     FROM public.sites
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE sites.id = resources.site_id
       AND group_users.user_id = auth.uid()
   )
);

CREATE POLICY "resources_insert_policy"
ON public.resources
FOR INSERT
TO authenticated
WITH CHECK (
   EXISTS (
     SELECT 1
     FROM public.sites
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE sites.id = resources.site_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner','admin')
   )
);

CREATE POLICY "resources_update_policy"
ON public.resources
FOR UPDATE
TO authenticated
USING (
   EXISTS (
     SELECT 1
     FROM public.sites
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE sites.id = resources.site_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner','admin')
   )
)
WITH CHECK (
   EXISTS (
     SELECT 1
     FROM public.sites
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE sites.id = resources.site_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner','admin')
   )
);

CREATE POLICY "resources_delete_policy"
ON public.resources
FOR DELETE
TO authenticated
USING (
   EXISTS (
     SELECT 1
     FROM public.sites
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE sites.id = resources.site_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner')
   )
);

-- -----------------------------------------------------
-- amenities
-- -----------------------------------------------------
-- Potentially any group might want to define an amenity. Or you might 
-- treat amenities as universal. Example policy: let any authenticated user SELECT, 
-- only admins insert new amenities (adjust as needed).

CREATE POLICY "amenities_select_policy"
ON public.amenities
FOR SELECT
TO authenticated
USING (true);

CREATE POLICY "amenities_insert_policy"
ON public.amenities
FOR INSERT
TO authenticated
WITH CHECK (
   -- Possibly require some role checks, or let anyone add?
   true
);

CREATE POLICY "amenities_update_policy"
ON public.amenities
FOR UPDATE
TO authenticated
USING (true)
WITH CHECK (true);

CREATE POLICY "amenities_delete_policy"
ON public.amenities
FOR DELETE
TO authenticated
USING (false); 
-- Example: disallow amenity deletion except for super admins in your system

-- -----------------------------------------------------
-- resource_amenities
-- -----------------------------------------------------
-- Many-to-many link. Typically only admins can attach or remove amenities.

CREATE POLICY "resource_amenities_select_policy"
ON public.resource_amenities
FOR SELECT
TO authenticated
USING (
   EXISTS (
     SELECT 1
     FROM public.resources
     JOIN public.sites ON sites.id = resources.site_id
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE resources.id = resource_amenities.resource_id
       AND group_users.user_id = auth.uid()
   )
);

CREATE POLICY "resource_amenities_insert_policy"
ON public.resource_amenities
FOR INSERT
TO authenticated
WITH CHECK (
   EXISTS (
     SELECT 1
     FROM public.resources
     JOIN public.sites ON sites.id = resources.site_id
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE resources.id = resource_amenities.resource_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner','admin')
   )
);

CREATE POLICY "resource_amenities_update_policy"
ON public.resource_amenities
FOR UPDATE
TO authenticated
USING (
   EXISTS (
     SELECT 1
     FROM public.resources
     JOIN public.sites ON sites.id = resources.site_id
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE resources.id = resource_amenities.resource_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner','admin')
   )
)
WITH CHECK (
   EXISTS (
     SELECT 1
     FROM public.resources
     JOIN public.sites ON sites.id = resources.site_id
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE resources.id = resource_amenities.resource_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner','admin')
   )
);

CREATE POLICY "resource_amenities_delete_policy"
ON public.resource_amenities
FOR DELETE
TO authenticated
USING (
   EXISTS (
     SELECT 1
     FROM public.resources
     JOIN public.sites ON sites.id = resources.site_id
     JOIN public.group_users ON group_users.group_id = sites.group_id
     WHERE resources.id = resource_amenities.resource_id
       AND group_users.user_id = auth.uid()
       AND group_users.role IN ('owner')
   )
);

-- -----------------------------------------------------
-- reservations
-- -----------------------------------------------------
-- 1) Only group members can see that the reservation exists (i.e. resource is booked).
-- 2) The user who owns the reservation sees the full details (title, description, etc.).
-- 3) Another group member sees that the resource is booked but *not* the private fields
--    (unless we choose to grant them).
-- 4) Possibly, participants also see details.

-- We'll create two separate policies:
--   a) SELECT: "Can see minimal or full detail"
--   b) Insert/Update/Delete: only the user or group admins.

CREATE POLICY "reservations_select_policy"
ON public.reservations
FOR SELECT
TO authenticated
USING (
  -- Condition for row visibility
  -- 1) The user own this reservation, or
  user_id = auth.uid()
  OR
  -- 2) They are an admin of the corresponding group
  EXISTS (
    SELECT 1
    FROM public.resources
    JOIN public.sites ON sites.id = resources.site_id
    JOIN public.group_users ON group_users.group_id = sites.group_id
    WHERE resources.id = reservations.resource_id
      AND group_users.user_id = auth.uid()
      AND group_users.role IN ('owner','admin')
  )
  OR
  -- 3) This user’s email appears in the participants array
  auth.email() = ANY(reservations.participants)
);

CREATE POLICY "reservations_insert_policy"
ON public.reservations
FOR INSERT
TO authenticated
WITH CHECK (
  -- The user can create a reservation if they are a group member
  -- or if there's no membership requirement. Adjust as needed:
  EXISTS (
    SELECT 1
    FROM public.resources
    JOIN public.sites ON sites.id = resources.site_id
    JOIN public.group_users ON group_users.group_id = sites.group_id
    WHERE resources.id = reservations.resource_id
      AND group_users.user_id = auth.uid()
  )
  AND (user_id = auth.uid())  -- typically the user booking is themselves
);

CREATE POLICY "reservations_update_policy"
ON public.reservations
FOR UPDATE
TO authenticated
USING (
  -- The user must either be the reservation owner
  user_id = auth.uid()
  OR
  -- or an admin in the group
  EXISTS (
    SELECT 1
    FROM public.resources
    JOIN public.sites ON sites.id = resources.site_id
    JOIN public.group_users ON group_users.group_id = sites.group_id
    WHERE resources.id = reservations.resource_id
      AND group_users.user_id = auth.uid()
      AND group_users.role IN ('owner','admin')
  )
)
WITH CHECK (
  user_id = auth.uid()
  OR
  EXISTS (
    SELECT 1
    FROM public.resources
    JOIN public.sites ON sites.id = resources.site_id
    JOIN public.group_users ON group_users.group_id = sites.group_id
    WHERE resources.id = reservations.resource_id
      AND group_users.user_id = auth.uid()
      AND group_users.role IN ('owner','admin')
  )
);

CREATE POLICY "reservations_delete_policy"
ON public.reservations
FOR DELETE
TO authenticated
USING (
  user_id = auth.uid()
  OR
  EXISTS (
    SELECT 1
    FROM public.resources
    JOIN public.sites ON sites.id = resources.site_id
    JOIN public.group_users ON group_users.group_id = sites.group_id
    WHERE resources.id = reservations.resource_id
      AND group_users.user_id = auth.uid()
      AND group_users.role IN ('owner','admin')
  )
);

-- =====================================================
-- 9. Useful indexes for performance
-- =====================================================

CREATE INDEX IF NOT EXISTS idx_group_users_group_id ON public.group_users(group_id);
CREATE INDEX IF NOT EXISTS idx_group_users_user_id ON public.group_users(user_id);

CREATE INDEX IF NOT EXISTS idx_sites_group_id ON public.sites(group_id);
CREATE INDEX IF NOT EXISTS idx_resources_site_id ON public.resources(site_id);

CREATE INDEX IF NOT EXISTS idx_resource_amenities_resource_id ON public.resource_amenities(resource_id);
CREATE INDEX IF NOT EXISTS idx_resource_amenities_amenity_id ON public.resource_amenities(amenity_id);

CREATE INDEX IF NOT EXISTS idx_reservations_resource_id ON public.reservations(resource_id);
CREATE INDEX IF NOT EXISTS idx_reservations_user_id ON public.reservations(user_id);
CREATE INDEX IF NOT EXISTS idx_reservations_time ON public.reservations(start_time, end_time);

-- Done

CREATE OR REPLACE FUNCTION is_group_admin(_group_id uuid, _uid uuid)
  RETURNS boolean
  LANGUAGE sql
  SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1
    FROM public.group_users
    WHERE group_id = _group_id
      AND user_id = _uid
      AND role IN ('owner','admin')
  );
$$;

DROP FUNCTION IF EXISTS get_user_id_by_email(_email text);

CREATE OR REPLACE FUNCTION get_user_id_by_email(_email text)
RETURNS uuid
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
DECLARE
  _user_id uuid;
BEGIN
  SELECT id INTO _user_id
  FROM auth.users
  WHERE email = _email;
  
  RETURN _user_id;
END;
$$;

DROP FUNCTION IF EXISTS get_group_members(uuid);

CREATE OR REPLACE FUNCTION get_group_members(_group_id uuid)
RETURNS TABLE (
  id uuid,
  user_id uuid,
  role varchar(50),
  email varchar(255)
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    gu.id,
    gu.user_id,
    gu.role,
    au.email
  FROM group_users gu
  JOIN auth.users au ON au.id = gu.user_id
  WHERE gu.group_id = _group_id;
END;
$$;

DROP FUNCTION IF EXISTS get_group_with_member_count(uuid);

CREATE OR REPLACE FUNCTION get_group_with_member_count(_user_id uuid)
RETURNS TABLE (
  id uuid,
  name varchar(255),
  description text,
  user_role varchar(50),
  member_count bigint
)
LANGUAGE plpgsql
SECURITY DEFINER
SET search_path = public
AS $$
BEGIN
  RETURN QUERY
  SELECT 
    g.id,
    g.name,
    g.description,
    gu.role as user_role,
    (SELECT COUNT(*) FROM group_users WHERE group_id = g.id) as member_count
  FROM groups g
  JOIN group_users gu ON g.id = gu.group_id
  WHERE gu.user_id = _user_id;
END;
$$;